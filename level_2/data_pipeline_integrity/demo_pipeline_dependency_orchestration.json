{
  "workflow_name": "intelligent_pipeline_dependency_orchestration",
  "description": "Orchestrate complex pipeline dependencies with automatic scheduling optimization and failure isolation",
  "goal": "Manage pipeline execution order based on dependencies while optimizing for parallelism and resource usage",
  "trigger": {
    "type": "cron",
    "schedule": "0 */2 * * *",
    "timezone": "UTC"
  },
  "inputs": {
    "orchestration_window": "${trigger.scheduled_time}",
    "pipeline_registry": "s3://pipeline-configs/registry.json",
    "resource_constraints": "${config.cluster_resources}"
  },
  "steps": [
    {
      "step": 1,
      "action": "build_dependency_graph",
      "integration": "aws.neptune.ExecuteGremlinQuery",
      "parameters": {
        "query": "g.V().hasLabel('Pipeline').where(__.out('scheduled_for').has('window', '${inputs.orchestration_window}')).project('id', 'dependencies', 'priority', 'resource_requirements').by('pipeline_id').by(__.in('depends_on').values('pipeline_id').fold()).by('priority').by('resource_requirements')",
        "serializer": "JSON"
      },
      "output": "dependency_graph"
    },
    {
      "step": 2,
      "action": "analyze_resource_availability",
      "integration": "kubernetes.CoreV1Api.list_node",
      "parameters": {
        "label_selector": "node-type=data-processing"
      },
      "transform": {
        "available_cpu": "sum(nodes.status.allocatable.cpu)",
        "available_memory": "sum(nodes.status.allocatable.memory)",
        "available_gpu": "sum(nodes.status.allocatable['nvidia.com/gpu'])"
      },
      "output": "cluster_resources"
    },
    {
      "step": 3,
      "action": "check_data_readiness",
      "integration": "aws.s3.ListObjectsV2",
      "parallel": true,
      "for_each": "${dependency_graph.pipelines}",
      "parameters": {
        "Bucket": "${pipeline.input_bucket}",
        "Prefix": "${pipeline.input_prefix}/${inputs.orchestration_window}/",
        "MaxKeys": 1
      },
      "output": "data_readiness_status"
    },
    {
      "step": 4,
      "action": "calculate_optimal_schedule",
      "integration": "aws.lambda.Invoke",
      "parameters": {
        "FunctionName": "pipeline-scheduler-optimizer",
        "Payload": {
          "dependency_graph": "${dependency_graph}",
          "resource_availability": "${cluster_resources}",
          "data_readiness": "${data_readiness_status}",
          "optimization_goals": {
            "minimize_total_time": 0.4,
            "maximize_parallelism": 0.3,
            "minimize_resource_cost": 0.3
          }
        }
      },
      "output": "execution_schedule"
    },
    {
      "step": 5,
      "action": "create_execution_plan",
      "integration": "aws.stepfunctions.CreateStateMachine",
      "parameters": {
        "name": "pipeline-orchestration-${inputs.orchestration_window}",
        "definition": "${execution_schedule.state_machine_definition}",
        "roleArn": "${config.step_functions_role}",
        "type": "EXPRESS",
        "loggingConfiguration": {
          "level": "ALL",
          "includeExecutionData": true,
          "destinations": [{
            "cloudWatchLogsLogGroup": {
              "logGroupArn": "arn:aws:logs:${region}:${account}:log-group:/aws/stepfunctions/pipeline-orchestration"
            }
          }]
        }
      },
      "output": "orchestration_state_machine"
    },
    {
      "step": 6,
      "action": "provision_compute_resources",
      "integration": "aws.emr.RunJobFlow",
      "condition": "${execution_schedule.requires_emr_cluster}",
      "parameters": {
        "Name": "pipeline-cluster-${inputs.orchestration_window}",
        "ReleaseLabel": "emr-6.10.0",
        "Instances": {
          "InstanceGroups": "${execution_schedule.emr_instance_groups}",
          "Ec2SubnetId": "${config.compute_subnet}",
          "KeepJobFlowAliveWhenNoSteps": false
        },
        "StepConcurrencyLevel": "${execution_schedule.max_parallel_steps}",
        "AutoTerminationPolicy": {
          "IdleTimeout": 3600
        }
      },
      "output": "emr_cluster_id"
    },
    {
      "step": 7,
      "action": "deploy_kubernetes_jobs",
      "integration": "kubernetes.BatchV1Api.create_namespaced_job",
      "parallel": true,
      "for_each": "${execution_schedule.kubernetes_pipelines}",
      "parameters": {
        "namespace": "data-pipelines",
        "body": {
          "metadata": {
            "name": "pipeline-${pipeline.id}-${timestamp()}",
            "labels": {
              "orchestration-window": "${inputs.orchestration_window}",
              "pipeline-id": "${pipeline.id}"
            }
          },
          "spec": {
            "parallelism": "${pipeline.parallelism}",
            "completions": "${pipeline.completions}",
            "template": {
              "spec": {
                "containers": [{
                  "name": "pipeline-executor",
                  "image": "${pipeline.container_image}",
                  "resources": "${pipeline.resource_requirements}",
                  "env": "${pipeline.environment_variables}"
                }],
                "restartPolicy": "OnFailure"
              }
            }
          }
        }
      },
      "output": "k8s_job_names"
    },
    {
      "step": 8,
      "action": "start_orchestration_execution",
      "integration": "aws.stepfunctions.StartExecution",
      "parameters": {
        "stateMachineArn": "${orchestration_state_machine.stateMachineArn}",
        "input": {
          "pipelines": "${execution_schedule.pipeline_execution_order}",
          "emr_cluster_id": "${emr_cluster_id}",
          "k8s_jobs": "${k8s_job_names}",
          "monitoring_config": {
            "alert_on_failure": true,
            "sla_minutes": "${execution_schedule.total_sla_minutes}"
          }
        }
      },
      "output": "orchestration_execution"
    },
    {
      "step": 9,
      "action": "monitor_pipeline_progress",
      "integration": "datadog.MetricsApi.query_timeseries_data",
      "parameters": {
        "query": "sum:pipeline.execution.progress{orchestration_id:${orchestration_execution.executionArn}} by {pipeline_id}",
        "from": "${now() - 300}",
        "to": "${now()}"
      },
      "retry": {
        "max_attempts": 60,
        "interval": 60,
        "until": "all_pipelines_complete"
      },
      "output": "execution_progress"
    },
    {
      "step": 10,
      "action": "detect_bottlenecks",
      "integration": "aws.cloudwatch.GetMetricData",
      "parameters": {
        "MetricDataQueries": [
          {
            "Id": "cpu_utilization",
            "MetricStat": {
              "Metric": {
                "Namespace": "AWS/EMR",
                "MetricName": "CPUUtilization",
                "Dimensions": [{"Name": "JobFlowId", "Value": "${emr_cluster_id}"}]
              },
              "Period": 300,
              "Stat": "Average"
            }
          },
          {
            "Id": "data_transfer_rate",
            "MetricStat": {
              "Metric": {
                "Namespace": "AWS/S3",
                "MetricName": "BytesDownloaded",
                "Dimensions": [{"Name": "BucketName", "Value": "${config.data_bucket}"}]
              },
              "Period": 300,
              "Stat": "Sum"
            }
          }
        ],
        "StartTime": "${orchestration_execution.startDate}",
        "EndTime": "${now()}"
      },
      "output": "performance_metrics"
    },
    {
      "step": 11,
      "action": "handle_pipeline_failures",
      "integration": "aws.lambda.InvokeAsync",
      "condition": "${execution_progress.failed_pipelines.length > 0}",
      "parameters": {
        "FunctionName": "pipeline-failure-handler",
        "InvokeArgs": {
          "failed_pipelines": "${execution_progress.failed_pipelines}",
          "dependency_graph": "${dependency_graph}",
          "recovery_strategies": {
            "retry_with_backoff": true,
            "use_cached_results": true,
            "skip_non_critical": true
          }
        }
      },
      "output": "failure_handling_result"
    },
    {
      "step": 12,
      "action": "collect_execution_lineage",
      "integration": "aws.glue.GetDataCatalogEncryptionSettings",
      "parameters": {
        "CatalogId": "${account_id}"
      },
      "followed_by": {
        "action": "record_lineage",
        "integration": "aws.dynamodb.PutItem",
        "parameters": {
          "TableName": "pipeline-execution-lineage",
          "Item": {
            "execution_id": "${orchestration_execution.executionArn}",
            "orchestration_window": "${inputs.orchestration_window}",
            "pipelines_executed": "${execution_progress.completed_pipelines}",
            "data_inputs": "${execution_schedule.data_dependencies}",
            "data_outputs": "${execution_progress.output_locations}",
            "execution_duration_seconds": "${execution_progress.total_duration}",
            "resource_cost_estimate": "${performance_metrics.cost_estimate}"
          }
        }
      },
      "output": "lineage_record"
    },
    {
      "step": 13,
      "action": "optimize_future_schedules",
      "integration": "aws.sagemaker.InvokeEndpoint",
      "parameters": {
        "EndpointName": "schedule-optimization-model",
        "Body": {
          "historical_executions": "${lineage_record}",
          "performance_metrics": "${performance_metrics}",
          "bottleneck_analysis": "${execution_progress.bottlenecks}",
          "resource_utilization": "${cluster_resources.utilization_history}"
        }
      },
      "output": "schedule_recommendations"
    },
    {
      "step": 14,
      "action": "cleanup_resources",
      "integration": "aws.emr.TerminateJobFlows",
      "condition": "${emr_cluster_id != null}",
      "parameters": {
        "JobFlowIds": ["${emr_cluster_id}"]
      },
      "followed_by": {
        "action": "cleanup_k8s_jobs",
        "integration": "kubernetes.BatchV1Api.delete_collection_namespaced_job",
        "parameters": {
          "namespace": "data-pipelines",
          "label_selector": "orchestration-window=${inputs.orchestration_window}"
        }
      },
      "output": "cleanup_result"
    },
    {
      "step": 15,
      "action": "send_orchestration_summary",
      "integration": "aws.ses.SendEmail",
      "parameters": {
        "Source": "pipeline-orchestrator@company.com",
        "Destination": {
          "ToAddresses": "${config.stakeholder_emails}"
        },
        "Message": {
          "Subject": {
            "Data": "Pipeline Orchestration Summary - ${inputs.orchestration_window}"
          },
          "Body": {
            "Html": {
              "Data": "<h2>Orchestration Results</h2><ul><li>Total Pipelines: ${execution_progress.total_pipelines}</li><li>Successful: ${execution_progress.successful_count}</li><li>Failed: ${execution_progress.failed_count}</li><li>Duration: ${execution_progress.total_duration} seconds</li><li>Cost Estimate: $${performance_metrics.cost_estimate}</li></ul><h3>Recommendations</h3><p>${schedule_recommendations.summary}</p>"
            }
          }
        }
      },
      "output": "notification_result"
    }
  ],
  "error_handling": {
    "strategy": "isolate_failures",
    "continue_on_non_critical_failure": true,
    "failure_threshold": 0.3,
    "escalation_policy": "on-call-data-engineer"
  },
  "outputs": {
    "execution_id": "${orchestration_execution.executionArn}",
    "pipelines_completed": "${execution_progress.completed_pipelines}",
    "total_duration_seconds": "${execution_progress.total_duration}",
    "optimization_recommendations": "${schedule_recommendations}",
    "next_window_schedule": "${schedule_recommendations.next_window_plan}"
  }
}