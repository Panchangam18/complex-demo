{
  "workflow_name": "intelligent_load_balancing_optimization",
  "description": "Dynamically optimize load balancing strategies based on real-time traffic patterns and service health",
  "goal": "Ensure optimal traffic distribution across services while minimizing latency and maximizing availability",
  "trigger": {
    "type": "stream",
    "source": "kinesis:LoadBalancerMetricsStream",
    "batch_window": 30
  },
  "inputs": {
    "lb_metrics": "${event.Records}",
    "service_topology": "${config.service_mesh_topology}",
    "sla_requirements": "${config.service_slas}"
  },
  "steps": [
    {
      "step": 1,
      "action": "analyze_traffic_distribution",
      "integration": "aws.elasticloadbalancingv2.DescribeTargetHealth",
      "parallel": true,
      "for_each": "${inputs.service_topology.load_balancers}",
      "parameters": {
        "TargetGroupArn": "${lb.target_group_arn}"
      },
      "output": "target_health_status"
    },
    {
      "step": 2,
      "action": "collect_endpoint_metrics",
      "integration": "datadog.MetricsApi.query_timeseries_data",
      "parameters": {
        "query": "avg:nginx.net.request_per_s{*} by {upstream}, avg:nginx.net.upstream.response_time{*} by {upstream}, sum:nginx.net.upstream.fails{*} by {upstream}",
        "from": "${now() - 300}",
        "to": "${now()}"
      },
      "output": "endpoint_performance"
    },
    {
      "step": 3,
      "action": "detect_traffic_anomalies",
      "integration": "aws.lambda.Invoke",
      "parameters": {
        "FunctionName": "traffic-anomaly-detector",
        "Payload": {
          "current_metrics": "${inputs.lb_metrics}",
          "historical_baseline": "${getTrafficBaseline()}",
          "detection_config": {
            "sensitivity": "high",
            "methods": ["statistical", "ml_based", "rule_based"],
            "window_size": 300
          }
        }
      },
      "output": "traffic_anomalies"
    },
    {
      "step": 4,
      "action": "evaluate_geographic_distribution",
      "integration": "aws.cloudfront.GetDistributionConfig",
      "parameters": {
        "Id": "${config.cloudfront_distribution_id}"
      },
      "followed_by": {
        "action": "analyze_geo_metrics",
        "integration": "aws.cloudwatch.GetMetricData",
        "parameters": {
          "MetricDataQueries": [{
            "Id": "origin_latency_by_region",
            "Expression": "SEARCH(' {AWS/CloudFront,DistributionId,Region} MetricName=\"OriginLatency\" ', 'Average', 300)"
          }]
        }
      },
      "output": "geo_distribution_metrics"
    },
    {
      "step": 5,
      "action": "calculate_optimal_weights",
      "integration": "aws.sagemaker.InvokeEndpoint",
      "parameters": {
        "EndpointName": "load-balancing-optimizer",
        "Body": {
          "target_health": "${target_health_status}",
          "endpoint_metrics": "${endpoint_performance}",
          "traffic_patterns": "${traffic_anomalies}",
          "geo_distribution": "${geo_distribution_metrics}",
          "constraints": {
            "min_healthy_targets": 2,
            "max_latency_ms": 100,
            "capacity_buffer": 0.2
          }
        }
      },
      "output": "optimal_lb_config"
    },
    {
      "step": 6,
      "action": "update_weighted_routing",
      "integration": "aws.route53.ChangeResourceRecordSets",
      "condition": "${optimal_lb_config.requires_dns_update}",
      "parameters": {
        "HostedZoneId": "${config.hosted_zone_id}",
        "ChangeBatch": {
          "Changes": "${optimal_lb_config.dns_changes.map(change => ({Action: 'UPSERT', ResourceRecordSet: change}))}"
        }
      },
      "output": "dns_update_result"
    },
    {
      "step": 7,
      "action": "configure_application_load_balancer",
      "integration": "aws.elasticloadbalancingv2.ModifyRule",
      "parallel": true,
      "for_each": "${optimal_lb_config.alb_rules}",
      "parameters": {
        "RuleArn": "${rule.arn}",
        "Actions": [{
          "Type": "forward",
          "ForwardConfig": {
            "TargetGroups": "${rule.weighted_targets}",
            "StickynessConfig": {
              "Enabled": "${rule.enable_stickiness}",
              "DurationSeconds": "${rule.stickiness_duration}"
            }
          }
        }]
      },
      "output": "alb_updates"
    },
    {
      "step": 8,
      "action": "implement_circuit_breakers",
      "integration": "istio.NetworkingV1alpha3Api.patch_namespaced_destination_rule",
      "condition": "${traffic_anomalies.unhealthy_endpoints.length > 0}",
      "parameters": {
        "name": "${service.name}-circuit-breaker",
        "namespace": "production",
        "body": {
          "spec": {
            "trafficPolicy": {
              "connectionPool": {
                "tcp": {
                  "maxConnections": "${optimal_lb_config.max_connections}"
                },
                "http": {
                  "http1MaxPendingRequests": "${optimal_lb_config.max_pending_requests}",
                  "http2MaxRequests": "${optimal_lb_config.max_http2_requests}"
                }
              },
              "outlierDetection": {
                "consecutive5xxErrors": 5,
                "interval": "30s",
                "baseEjectionTime": "30s",
                "maxEjectionPercent": 50
              }
            }
          }
        }
      },
      "output": "circuit_breaker_config"
    },
    {
      "step": 9,
      "action": "enable_adaptive_retries",
      "integration": "aws.appmesh.UpdateVirtualService",
      "parameters": {
        "meshName": "${config.app_mesh_name}",
        "virtualServiceName": "${service.virtual_service_name}",
        "spec": {
          "provider": {
            "virtualRouter": {
              "virtualRouterName": "${service.virtual_router_name}"
            }
          },
          "retryPolicy": {
            "maxRetries": "${optimal_lb_config.retry_config.max_retries}",
            "perRetryTimeout": {
              "value": "${optimal_lb_config.retry_config.timeout}",
              "unit": "ms"
            },
            "httpRetryEvents": ["server-error", "gateway-error", "reset"]
          }
        }
      },
      "output": "retry_policy_update"
    },
    {
      "step": 10,
      "action": "deploy_canary_routing",
      "integration": "aws.apigatewayv2.UpdateStage",
      "condition": "${optimal_lb_config.canary_deployment}",
      "parameters": {
        "ApiId": "${config.api_gateway_id}",
        "StageName": "production",
        "RouteSettings": {
          "${optimal_lb_config.canary_route}": {
            "ThrottlingBurstLimit": "${optimal_lb_config.burst_limit}",
            "ThrottlingRateLimit": "${optimal_lb_config.rate_limit}"
          }
        },
        "DeploymentId": "${createCanaryDeployment()}"
      },
      "output": "canary_deployment_result"
    },
    {
      "step": 11,
      "action": "validate_load_distribution",
      "integration": "prometheus.CustomApi.query_range",
      "parameters": {
        "query": "rate(http_requests_total[5m]) by (instance)",
        "start": "${now() - 300}",
        "end": "${now()}",
        "step": "15s"
      },
      "transform": {
        "distribution_variance": "calculateVariance(result.values)",
        "distribution_score": "1 - (distribution_variance / max_acceptable_variance)"
      },
      "output": "distribution_validation"
    },
    {
      "step": 12,
      "action": "optimize_health_checks",
      "integration": "aws.elasticloadbalancingv2.ModifyTargetGroup",
      "parallel": true,
      "for_each": "${optimal_lb_config.health_check_updates}",
      "parameters": {
        "TargetGroupArn": "${target_group.arn}",
        "HealthCheckIntervalSeconds": "${target_group.optimal_interval}",
        "HealthCheckTimeoutSeconds": "${target_group.optimal_timeout}",
        "HealthyThresholdCount": "${target_group.healthy_threshold}",
        "UnhealthyThresholdCount": "${target_group.unhealthy_threshold}",
        "Matcher": {
          "HttpCode": "${target_group.success_codes}"
        }
      },
      "output": "health_check_updates"
    },
    {
      "step": 13,
      "action": "update_waf_rules",
      "integration": "aws.wafv2.UpdateWebACL",
      "condition": "${traffic_anomalies.suspicious_patterns}",
      "parameters": {
        "Scope": "REGIONAL",
        "Id": "${config.waf_acl_id}",
        "Rules": [{
          "Name": "RateLimitByIP",
          "Priority": 1,
          "Statement": {
            "RateBasedStatement": {
              "Limit": "${optimal_lb_config.rate_limit_per_ip}",
              "AggregateKeyType": "IP"
            }
          },
          "Action": {
            "Block": {}
          }
        }]
      },
      "output": "waf_update_result"
    },
    {
      "step": 14,
      "action": "broadcast_configuration_changes",
      "integration": "aws.sns.Publish",
      "parameters": {
        "TopicArn": "arn:aws:sns:${region}:${account}:load-balancer-updates",
        "Subject": "Load Balancer Configuration Updated",
        "Message": {
          "timestamp": "${now()}",
          "changes": {
            "dns_updates": "${dns_update_result}",
            "alb_updates": "${alb_updates}",
            "circuit_breakers": "${circuit_breaker_config}",
            "canary_status": "${canary_deployment_result}"
          },
          "performance_impact": {
            "latency_improvement": "${distribution_validation.latency_delta}",
            "error_rate_change": "${distribution_validation.error_rate_delta}"
          }
        }
      },
      "output": "notification_result"
    },
    {
      "step": 15,
      "action": "schedule_effectiveness_review",
      "integration": "aws.scheduler.CreateSchedule",
      "parameters": {
        "Name": "lb-effectiveness-review-${execution_id}",
        "ScheduleExpression": "at(${now() + 3600})",
        "Target": {
          "Arn": "arn:aws:lambda:${region}:${account}:function:lb-effectiveness-analyzer",
          "RoleArn": "${config.scheduler_role}",
          "Input": {
            "optimization_config": "${optimal_lb_config}",
            "baseline_metrics": "${endpoint_performance}",
            "expected_improvements": {
              "latency_reduction": "${optimal_lb_config.expected_latency_improvement}",
              "error_reduction": "${optimal_lb_config.expected_error_reduction}"
            }
          }
        }
      },
      "output": "review_schedule"
    }
  ],
  "error_handling": {
    "strategy": "graceful_degradation",
    "fallback_lb_config": "round_robin_equal_weight",
    "health_check_failures": "isolate_unhealthy_targets",
    "partial_update_success": "continue_with_working_targets"
  },
  "outputs": {
    "optimization_applied": "${optimal_lb_config.summary}",
    "traffic_distribution": "${distribution_validation}",
    "performance_metrics": {
      "latency_p99": "${endpoint_performance.p99_latency}",
      "error_rate": "${endpoint_performance.error_rate}",
      "throughput": "${endpoint_performance.requests_per_second}"
    },
    "next_optimization": "${review_schedule.scheduled_time}"
  }
}