{
  "workflow_name": "intelligent_auto_scaling_optimization",
  "description": "Real-time auto-scaling with predictive analytics and cost optimization",
  "goal": "Automatically scale infrastructure based on predictive load patterns while optimizing for cost and performance",
  "trigger": {
    "type": "composite",
    "triggers": [
      {"type": "metric", "source": "cloudwatch:CPUUtilization > 70%"},
      {"type": "metric", "source": "datadog:request_rate > threshold"},
      {"type": "schedule", "cron": "*/5 * * * *"}
    ]
  },
  "inputs": {
    "current_metrics": "${trigger.metrics}",
    "service_name": "${trigger.service}",
    "environment": "${trigger.environment}"
  },
  "steps": [
    {
      "step": 1,
      "action": "collect_performance_metrics",
      "integration": "datadog.MetricsApi.query_timeseries_data",
      "parameters": {
        "query": "avg:system.cpu.user{service:${inputs.service_name}}, avg:aws.elb.request_count{service:${inputs.service_name}}, avg:custom.app.response_time{service:${inputs.service_name}}",
        "from": "${now() - 3600}",
        "to": "${now()}"
      },
      "output": "current_performance"
    },
    {
      "step": 2,
      "action": "analyze_traffic_patterns",
      "integration": "aws.cloudwatch.GetMetricStatistics",
      "parameters": {
        "Namespace": "AWS/ApplicationELB",
        "MetricName": "RequestCountPerTarget",
        "Dimensions": [
          {"Name": "LoadBalancer", "Value": "${inputs.service_name}-alb"}
        ],
        "StartTime": "${now() - 86400}",
        "EndTime": "${now()}",
        "Period": 300,
        "Statistics": ["Average", "Maximum", "Minimum"]
      },
      "output": "traffic_patterns"
    },
    {
      "step": 3,
      "action": "predict_future_load",
      "integration": "aws.sagemaker.InvokeEndpoint",
      "parameters": {
        "EndpointName": "load-prediction-model",
        "Body": {
          "historical_metrics": "${current_performance}",
          "traffic_patterns": "${traffic_patterns}",
          "time_features": {
            "hour_of_day": "${hour()}",
            "day_of_week": "${dayOfWeek()}",
            "is_holiday": "${isHoliday()}"
          },
          "forecast_window_minutes": 30
        }
      },
      "output": "load_prediction"
    },
    {
      "step": 4,
      "action": "calculate_optimal_capacity",
      "integration": "aws.lambda.Invoke",
      "parameters": {
        "FunctionName": "capacity-optimizer",
        "Payload": {
          "predicted_load": "${load_prediction}",
          "current_capacity": "${current_performance.instance_count}",
          "sla_requirements": {
            "target_response_time_ms": 200,
            "availability_target": 0.999
          },
          "cost_constraints": {
            "max_hourly_cost": 500,
            "spot_instance_preference": 0.7
          }
        }
      },
      "output": "optimal_capacity"
    },
    {
      "step": 5,
      "action": "check_spot_instance_availability",
      "integration": "aws.ec2.DescribeSpotInstanceRequests",
      "parameters": {
        "Filters": [
          {"Name": "instance-type", "Values": "${optimal_capacity.instance_types}"},
          {"Name": "availability-zone", "Values": "${optimal_capacity.availability_zones}"}
        ]
      },
      "output": "spot_availability"
    },
    {
      "step": 6,
      "action": "update_auto_scaling_policy",
      "integration": "aws.autoscaling.PutScalingPolicy",
      "parameters": {
        "AutoScalingGroupName": "${inputs.service_name}-asg",
        "PolicyName": "predictive-scaling-${timestamp()}",
        "PolicyType": "PredictiveScaling",
        "PredictiveScalingConfiguration": {
          "MetricSpecifications": [{
            "TargetValue": "${optimal_capacity.target_cpu_utilization}",
            "PredefinedMetricPairSpecification": {
              "PredefinedMetricType": "ASGCPUUtilization"
            }
          }],
          "Mode": "ForecastAndScale",
          "SchedulingBufferTime": 600
        }
      },
      "output": "scaling_policy"
    },
    {
      "step": 7,
      "action": "pre_warm_instances",
      "integration": "aws.ec2.RunInstances",
      "condition": "${optimal_capacity.requires_pre_warming}",
      "parameters": {
        "ImageId": "${optimal_capacity.ami_id}",
        "InstanceType": "${optimal_capacity.instance_type}",
        "MinCount": "${optimal_capacity.pre_warm_count}",
        "MaxCount": "${optimal_capacity.pre_warm_count}",
        "LaunchTemplate": {
          "LaunchTemplateId": "${inputs.service_name}-template",
          "Version": "$Latest"
        },
        "TagSpecifications": [{
          "ResourceType": "instance",
          "Tags": [
            {"Key": "PreWarmed", "Value": "true"},
            {"Key": "Service", "Value": "${inputs.service_name}"}
          ]
        }]
      },
      "output": "pre_warmed_instances"
    },
    {
      "step": 8,
      "action": "configure_load_balancer_routing",
      "integration": "aws.elbv2.ModifyTargetGroupAttributes",
      "parameters": {
        "TargetGroupArn": "${inputs.service_name}-tg",
        "Attributes": [
          {
            "Key": "deregistration_delay.timeout_seconds",
            "Value": "${optimal_capacity.deregistration_delay}"
          },
          {
            "Key": "load_balancing.algorithm.type",
            "Value": "${optimal_capacity.load_balancing_algorithm}"
          }
        ]
      },
      "output": "lb_configuration"
    },
    {
      "step": 9,
      "action": "implement_request_queueing",
      "integration": "aws.sqs.SetQueueAttributes",
      "condition": "${load_prediction.burst_expected}",
      "parameters": {
        "QueueUrl": "${inputs.service_name}-burst-queue",
        "Attributes": {
          "MessageRetentionPeriod": "300",
          "VisibilityTimeout": "${optimal_capacity.processing_time_estimate}",
          "ReddrivePolicy": {
            "deadLetterTargetArn": "${inputs.service_name}-dlq",
            "maxReceiveCount": 3
          }
        }
      },
      "output": "queue_configuration"
    },
    {
      "step": 10,
      "action": "update_caching_strategy",
      "integration": "aws.elasticache.ModifyCacheCluster",
      "parameters": {
        "CacheClusterId": "${inputs.service_name}-cache",
        "NumCacheNodes": "${optimal_capacity.cache_nodes}",
        "CacheNodeType": "${optimal_capacity.cache_node_type}",
        "ApplyImmediately": true
      },
      "output": "cache_update"
    },
    {
      "step": 11,
      "action": "adjust_database_connections",
      "integration": "aws.rds.ModifyDBInstance",
      "parameters": {
        "DBInstanceIdentifier": "${inputs.service_name}-db",
        "DBParameterGroupName": "${inputs.service_name}-params-${optimal_capacity.db_tier}",
        "ApplyImmediately": false,
        "PreferredMaintenanceWindow": "sun:05:00-sun:06:00"
      },
      "output": "db_configuration"
    },
    {
      "step": 12,
      "action": "deploy_performance_monitors",
      "integration": "datadog.MonitorsApi.create_monitor",
      "parameters": {
        "body": {
          "name": "Scaling Performance - ${inputs.service_name}",
          "type": "metric alert",
          "query": "avg(last_5m):avg:custom.scaling.efficiency{service:${inputs.service_name}} < 0.8",
          "message": "Scaling efficiency dropped below 80% for ${inputs.service_name}",
          "tags": ["service:${inputs.service_name}", "team:platform"],
          "options": {
            "thresholds": {"critical": 0.8, "warning": 0.85},
            "notify_no_data": true
          }
        }
      },
      "output": "performance_monitor"
    },
    {
      "step": 13,
      "action": "validate_scaling_effectiveness",
      "integration": "aws.cloudwatch.GetMetricData",
      "parameters": {
        "MetricDataQueries": [
          {
            "Id": "response_time_after_scaling",
            "Expression": "AVG(m1)",
            "Period": 300
          },
          {
            "Id": "m1",
            "MetricStat": {
              "Metric": {
                "Namespace": "AWS/ApplicationELB",
                "MetricName": "TargetResponseTime"
              },
              "Period": 60,
              "Stat": "Average"
            }
          }
        ],
        "StartTime": "${scaling_policy.timestamp}",
        "EndTime": "${now()}"
      },
      "output": "scaling_validation"
    },
    {
      "step": 14,
      "action": "calculate_cost_impact",
      "integration": "aws.ce.GetCostForecast",
      "parameters": {
        "TimePeriod": {
          "Start": "${today()}",
          "End": "${today() + 7}"
        },
        "Metric": "BLENDED_COST",
        "Granularity": "DAILY",
        "Filter": {
          "Tags": {
            "Key": "Service",
            "Values": ["${inputs.service_name}"]
          }
        },
        "PredictionIntervalLevel": 90
      },
      "output": "cost_forecast"
    },
    {
      "step": 15,
      "action": "update_scaling_intelligence",
      "integration": "aws.dynamodb.UpdateItem",
      "parameters": {
        "TableName": "scaling-intelligence",
        "Key": {
          "service_name": "${inputs.service_name}",
          "timestamp": "${now()}"
        },
        "UpdateExpression": "SET scaling_decision = :decision, predicted_vs_actual = :accuracy, cost_efficiency = :efficiency, learned_patterns = list_append(learned_patterns, :new_pattern)",
        "ExpressionAttributeValues": {
          ":decision": "${optimal_capacity}",
          ":accuracy": "${scaling_validation.accuracy_percentage}",
          ":efficiency": "${cost_forecast.efficiency_score}",
          ":new_pattern": [{
            "trigger": "${inputs.current_metrics}",
            "action": "${scaling_policy}",
            "outcome": "${scaling_validation}"
          }]
        }
      },
      "output": "intelligence_update"
    }
  ],
  "error_handling": {
    "strategy": "graceful_degradation",
    "fallback_capacity": "maintain_current",
    "alert_on_prediction_failure": true,
    "manual_override": "enabled"
  },
  "outputs": {
    "scaling_decision": "${optimal_capacity}",
    "predicted_load": "${load_prediction}",
    "cost_impact": "${cost_forecast}",
    "performance_improvement": "${scaling_validation.improvement_percentage}"
  }
}