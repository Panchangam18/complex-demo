{
  "workflow_name": "automated_chaos_experiment_orchestration",
  "description": "Orchestrate chaos experiments with intelligent targeting, safety controls, and automated learning",
  "goal": "Continuously test system resilience through controlled chaos experiments while ensuring safety and learning from results",
  "trigger": {
    "type": "scheduled",
    "schedule": "0 2 * * WED",
    "conditions": ["no_active_incidents", "all_services_healthy", "outside_peak_hours"]
  },
  "inputs": {
    "experiment_scope": "${config.chaos_scope}",
    "safety_threshold": "${config.max_blast_radius}",
    "learning_mode": "adaptive"
  },
  "steps": [
    {
      "step": 1,
      "action": "assess_system_readiness",
      "integration": "datadog.MonitorsApi.list_monitors",
      "parameters": {
        "group_states": "alert,warn",
        "tags": "chaos:eligible",
        "page_size": 100
      },
      "validation": {
        "no_critical_alerts": "${result.monitors.filter(m => m.overall_state === 'Alert').length === 0}",
        "warning_threshold": "${result.monitors.filter(m => m.overall_state === 'Warn').length < 5}"
      },
      "output": "system_health_status"
    },
    {
      "step": 2,
      "action": "select_experiment_targets",
      "integration": "aws.servicediscovery.ListServices",
      "parameters": {
        "Filters": [{
          "Name": "NAMESPACE_ID",
          "Values": ["${config.service_namespace}"],
          "Condition": "EQ"
        }]
      },
      "followed_by": {
        "action": "analyze_service_criticality",
        "integration": "aws.lambda.Invoke",
        "parameters": {
          "FunctionName": "service-criticality-analyzer",
          "Payload": {
            "services": "${result.Services}",
            "business_impact_matrix": "${config.business_impact_scores}",
            "dependency_graph": "${getServiceDependencyGraph()}"
          }
        }
      },
      "output": "experiment_targets"
    },
    {
      "step": 3,
      "action": "generate_experiment_hypothesis",
      "integration": "aws.bedrock.InvokeModel",
      "parameters": {
        "modelId": "anthropic.claude-v2",
        "body": {
          "prompt": "Generate chaos experiment hypothesis for:\nTargets: ${JSON.stringify(experiment_targets)}\nPrevious experiments: ${getPreviousExperiments()}\nKnown issues: ${getKnownIssues()}\n\nProvide specific hypothesis, expected behavior, and success criteria.",
          "max_tokens": 1500
        }
      },
      "output": "experiment_hypothesis"
    },
    {
      "step": 4,
      "action": "create_experiment_plan",
      "integration": "aws.fis.CreateExperimentTemplate",
      "parameters": {
        "description": "${experiment_hypothesis.description}",
        "targets": {
          "primary-targets": {
            "resourceType": "aws:ec2:instance",
            "resourceArns": "${experiment_targets.primary_instances}",
            "selectionMode": "COUNT(${Math.min(3, experiment_targets.primary_instances.length)})"
          }
        },
        "actions": {
          "inject-cpu-stress": {
            "actionId": "aws:ec2:stress-cpu",
            "parameters": {
              "duration": "PT5M",
              "percent": "80"
            },
            "targets": {
              "Instances": "primary-targets"
            }
          },
          "throttle-network": {
            "actionId": "aws:ec2:network-latency",
            "parameters": {
              "duration": "PT3M",
              "jitter": "100",
              "delay": "200"
            },
            "startAfter": ["inject-cpu-stress"]
          }
        },
        "stopConditions": [{
          "source": "aws:cloudwatch:alarm",
          "value": "${config.chaos_stop_alarm_arn}"
        }],
        "roleArn": "${config.fis_execution_role}"
      },
      "output": "experiment_template"
    },
    {
      "step": 5,
      "action": "deploy_monitoring_enhancement",
      "integration": "datadog.DashboardsApi.create_dashboard",
      "parameters": {
        "body": {
          "title": "Chaos Experiment - ${execution_id}",
          "description": "Real-time monitoring for chaos experiment",
          "widgets": [{
            "definition": {
              "type": "timeseries",
              "requests": [{
                "q": "avg:system.cpu.user{service:${experiment_targets.services}} by {host}",
                "display_type": "line"
              }]
            }
          }, {
            "definition": {
              "type": "query_value",
              "requests": [{
                "q": "avg:trace.servlet.request.errors{service:${experiment_targets.services}}.as_rate()",
                "aggregator": "avg"
              }]
            }
          }],
          "template_variables": [{
            "name": "service",
            "prefix": "service",
            "default": "${experiment_targets.services[0]}"
          }]
        }
      },
      "output": "monitoring_dashboard"
    },
    {
      "step": 6,
      "action": "establish_baseline_metrics",
      "integration": "prometheus.CustomApi.query_range",
      "parameters": {
        "query": "rate(http_request_duration_seconds[5m]) by (service, method, status)",
        "start": "${now() - 3600}",
        "end": "${now()}",
        "step": "60s"
      },
      "output": "baseline_metrics"
    },
    {
      "step": 7,
      "action": "start_experiment_recording",
      "integration": "aws.kinesis.PutRecord",
      "parameters": {
        "StreamName": "chaos-experiment-stream",
        "Data": {
          "experiment_id": "${execution_id}",
          "hypothesis": "${experiment_hypothesis}",
          "targets": "${experiment_targets}",
          "baseline": "${baseline_metrics}",
          "start_time": "${now()}"
        },
        "PartitionKey": "${execution_id}"
      },
      "output": "recording_started"
    },
    {
      "step": 8,
      "action": "execute_chaos_experiment",
      "integration": "aws.fis.StartExperiment",
      "parameters": {
        "experimentTemplateId": "${experiment_template.id}",
        "tags": {
          "experiment_id": "${execution_id}",
          "hypothesis": "${experiment_hypothesis.id}",
          "automated": "true"
        }
      },
      "output": "experiment_execution"
    },
    {
      "step": 9,
      "action": "monitor_experiment_progress",
      "integration": "aws.fis.GetExperiment",
      "parameters": {
        "id": "${experiment_execution.experiment.id}"
      },
      "retry": {
        "max_attempts": 30,
        "interval": 10,
        "until": "state.status != 'running'"
      },
      "output": "experiment_status"
    },
    {
      "step": 10,
      "action": "collect_impact_metrics",
      "integration": "datadog.MetricsApi.query_timeseries_data",
      "parameters": {
        "query": "avg:trace.servlet.request.errors{*} by {service}.as_rate(), avg:trace.servlet.request.duration{*} by {service}, avg:custom.business.metric{*} by {service}",
        "from": "${experiment_execution.experiment.startTime}",
        "to": "${experiment_status.experiment.endTime}"
      },
      "output": "impact_metrics"
    },
    {
      "step": 11,
      "action": "analyze_system_behavior",
      "integration": "aws.lambda.Invoke",
      "parameters": {
        "FunctionName": "chaos-behavior-analyzer",
        "Payload": {
          "baseline": "${baseline_metrics}",
          "during_experiment": "${impact_metrics}",
          "hypothesis": "${experiment_hypothesis}",
          "expected_behavior": {
            "degradation_threshold": 0.2,
            "recovery_time_sla": 300,
            "error_rate_increase": 0.1
          }
        }
      },
      "output": "behavior_analysis"
    },
    {
      "step": 12,
      "action": "identify_weaknesses",
      "integration": "aws.sagemaker.InvokeEndpoint",
      "parameters": {
        "EndpointName": "weakness-identification-model",
        "Body": {
          "experiment_data": "${experiment_status}",
          "behavior_analysis": "${behavior_analysis}",
          "system_topology": "${getSystemTopology()}",
          "historical_incidents": "${getIncidentHistory()}"
        }
      },
      "output": "identified_weaknesses"
    },
    {
      "step": 13,
      "action": "generate_remediation_tasks",
      "integration": "jira.IssuesApi.create_issue",
      "for_each": "${identified_weaknesses.actionable_items}",
      "parameters": {
        "body": {
          "fields": {
            "project": {"key": "RELIABILITY"},
            "summary": "Chaos Engineering Finding: ${weakness.title}",
            "description": "## Weakness Identified\n${weakness.description}\n\n## Impact\n${weakness.impact}\n\n## Recommended Fix\n${weakness.remediation}\n\n## Experiment Details\n- ID: ${execution_id}\n- Date: ${now()}\n- Hypothesis: ${experiment_hypothesis.summary}",
            "issuetype": {"name": "Task"},
            "priority": {"name": "${weakness.priority}"},
            "labels": ["chaos-engineering", "reliability", "automated"],
            "customfield_10001": "${weakness.estimated_effort}"
          }
        }
      },
      "output": "remediation_tasks"
    },
    {
      "step": 14,
      "action": "update_chaos_knowledge_base",
      "integration": "elasticsearch.IndexApi.index",
      "parameters": {
        "index": "chaos-experiments",
        "body": {
          "experiment_id": "${execution_id}",
          "timestamp": "${now()}",
          "hypothesis": "${experiment_hypothesis}",
          "targets": "${experiment_targets}",
          "results": "${behavior_analysis}",
          "weaknesses": "${identified_weaknesses}",
          "remediation_tasks": "${remediation_tasks}",
          "lessons_learned": {
            "successful_mitigations": "${behavior_analysis.successful_responses}",
            "failure_modes": "${behavior_analysis.failure_modes}",
            "unexpected_behaviors": "${behavior_analysis.unexpected_behaviors}"
          }
        }
      },
      "output": "knowledge_base_update"
    },
    {
      "step": 15,
      "action": "schedule_follow_up_experiment",
      "integration": "aws.scheduler.CreateSchedule",
      "condition": "${identified_weaknesses.requires_retest}",
      "parameters": {
        "Name": "chaos-followup-${execution_id}",
        "ScheduleExpression": "at(${now() + 604800})",
        "Target": {
          "Arn": "arn:aws:states:${region}:${account}:stateMachine:chaos-orchestration",
          "RoleArn": "${config.scheduler_role}",
          "Input": {
            "parent_experiment": "${execution_id}",
            "focus_areas": "${identified_weaknesses.retest_targets}",
            "hypothesis": "${behavior_analysis.follow_up_hypothesis}"
          }
        }
      },
      "output": "follow_up_scheduled"
    }
  ],
  "error_handling": {
    "strategy": "immediate_abort",
    "rollback_actions": ["stop_all_experiments", "restore_baseline_config"],
    "notification_channels": ["pagerduty", "slack"],
    "post_mortem_required": true
  },
  "outputs": {
    "experiment_id": "${execution_id}",
    "hypothesis_validated": "${behavior_analysis.hypothesis_result}",
    "weaknesses_found": "${identified_weaknesses.count}",
    "remediation_tasks_created": "${remediation_tasks.length}",
    "next_experiment_scheduled": "${follow_up_scheduled.scheduleArn}"
  }
}