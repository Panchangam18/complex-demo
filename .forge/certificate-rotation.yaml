goal: "Rotate SSL/TLS certificates across multicloud infrastructure with zero downtime"
generate_pr: true

triggers:
  - display_name: "Certificate Expiry Alert"
    description: "Triggered when certificates are within 30 days of expiry"
    provider: "monitoring"
    config:
      alert_name: "CertificateExpiring"
      threshold_days: 30
    labels:
      priority: "high"
      team: "security-ops"

steps:
  - name: "Certificate Inventory and Assessment"
    type: "action"
    description: "Discover and assess all certificates across the infrastructure"
    config:
      command: |
        #!/bin/bash
        set -euo pipefail
        
        echo "=== CERTIFICATE INVENTORY AND ASSESSMENT ==="
        
        ROTATION_ID="CERT-ROT-$(date +%Y%m%d%H%M%S)"
        echo "Certificate Rotation ID: $ROTATION_ID"
        
        # Create certificate inventory
        mkdir -p "/tmp/cert-inventory-$ROTATION_ID"
        
        # Discover AWS ACM certificates
        echo "Discovering AWS ACM certificates..."
        
        aws acm list-certificates --query 'CertificateSummaryList[*].[CertificateArn,DomainName]' --output table > "/tmp/cert-inventory-$ROTATION_ID/aws-acm.txt"
        
        # Get detailed certificate info
        aws acm list-certificates --query 'CertificateSummaryList[*].CertificateArn' --output text | while read -r cert_arn; do
          aws acm describe-certificate --certificate-arn "$cert_arn" --query 'Certificate.{Domain:DomainName,Status:Status,NotAfter:NotAfter,KeyAlgorithm:KeyAlgorithm,InUse:InUseBy}' --output json >> "/tmp/cert-inventory-$ROTATION_ID/aws-details.json"
        done
        
        # Discover GCP SSL certificates
        echo "Discovering GCP SSL certificates..."
        
        gcloud compute ssl-certificates list --format="table(name,creationTimestamp,expireTime)" > "/tmp/cert-inventory-$ROTATION_ID/gcp-ssl.txt"
        
        # Discover Azure certificates
        echo "Discovering Azure certificates..."
        
        az keyvault certificate list --vault-name prod-keyvault --query '[*].{Name:name,Enabled:attributes.enabled,Expires:attributes.expires}' --output table > "/tmp/cert-inventory-$ROTATION_ID/azure-kv.txt"
        
        # Discover Kubernetes certificates
        echo "Discovering Kubernetes certificates..."
        
        # Check across all clusters
        CLUSTERS=("eks-prod-us-east-1" "gke-prod-us-central1" "aks-prod-eastus")
        
        for cluster in "${CLUSTERS[@]}"; do
          kubectl config use-context "$cluster"
          
          # Get TLS secrets
          kubectl get secrets --all-namespaces --field-selector type=kubernetes.io/tls -o custom-columns="NAMESPACE:.metadata.namespace,NAME:.metadata.name,AGE:.metadata.creationTimestamp" > "/tmp/cert-inventory-$ROTATION_ID/k8s-tls-$cluster.txt"
          
          # Check certificate expiry in secrets
          kubectl get secrets --all-namespaces --field-selector type=kubernetes.io/tls -o json | jq -r '.items[] | {namespace: .metadata.namespace, name: .metadata.name, cert: .data."tls.crt"}' | while read -r secret_info; do
            namespace=$(echo "$secret_info" | jq -r '.namespace')
            name=$(echo "$secret_info" | jq -r '.name')
            cert_data=$(echo "$secret_info" | jq -r '.cert')
            
            if [ "$cert_data" != "null" ]; then
              echo "$cert_data" | base64 -d | openssl x509 -noout -dates -subject | sed "s/^/$namespace\/$name: /" >> "/tmp/cert-inventory-$ROTATION_ID/k8s-cert-details-$cluster.txt"
            fi
          done
        done
        
        # Discover load balancer certificates
        echo "Discovering load balancer certificates..."
        
        # ALB certificates
        aws elbv2 describe-load-balancers --query 'LoadBalancers[*].[LoadBalancerArn,DNSName]' --output text | while read -r alb_arn dns_name; do
          aws elbv2 describe-listeners --load-balancer-arn "$alb_arn" --query 'Listeners[*].Certificates[*].CertificateArn' --output text >> "/tmp/cert-inventory-$ROTATION_ID/alb-certs.txt"
        done
        
        # Check cert-manager certificates
        echo "Checking cert-manager certificates..."
        
        for cluster in "${CLUSTERS[@]}"; do
          kubectl config use-context "$cluster"
          
          if kubectl get crd certificates.cert-manager.io &>/dev/null; then
            kubectl get certificates --all-namespaces -o custom-columns="NAMESPACE:.metadata.namespace,NAME:.metadata.name,READY:.status.conditions[?(@.type=='Ready')].status,EXPIRY:.status.notAfter" > "/tmp/cert-inventory-$ROTATION_ID/cert-manager-$cluster.txt"
          fi
        done
        
        # Analyze certificate expiry
        echo "Analyzing certificate expiry..."
        
        python3 << 'EOF'
import json
import subprocess
from datetime import datetime, timedelta
import sys

rotation_id = sys.argv[1]
expiring_certs = []
current_time = datetime.now()
warning_threshold = current_time + timedelta(days=30)
critical_threshold = current_time + timedelta(days=7)

# Parse AWS certificates
try:
    with open(f'/tmp/cert-inventory-{rotation_id}/aws-details.json', 'r') as f:
        for line in f:
            cert = json.loads(line.strip())
            if cert.get('NotAfter'):
                expiry = datetime.fromisoformat(cert['NotAfter'].replace('Z', '+00:00'))
                if expiry < warning_threshold:
                    severity = 'critical' if expiry < critical_threshold else 'warning'
                    expiring_certs.append({
                        'domain': cert['Domain'],
                        'provider': 'AWS ACM',
                        'expiry': cert['NotAfter'],
                        'severity': severity,
                        'days_remaining': (expiry - current_time).days
                    })
except FileNotFoundError:
    pass

# Save results
with open(f'/tmp/cert-inventory-{rotation_id}/expiring-certs.json', 'w') as f:
    json.dump(expiring_certs, f, indent=2, default=str)

print(f"Found {len(expiring_certs)} expiring certificates")
for cert in expiring_certs:
    print(f"  {cert['domain']}: {cert['days_remaining']} days ({cert['severity']})")
EOF
        
        # Generate certificate report
        echo "Generating certificate report..."
        
        cat > "/tmp/cert-inventory-$ROTATION_ID/certificate-report.md" << EOF
# Certificate Inventory Report - $ROTATION_ID

## Summary
- **Report Date**: $(date)
- **AWS ACM Certificates**: $(wc -l < "/tmp/cert-inventory-$ROTATION_ID/aws-acm.txt")
- **GCP SSL Certificates**: $(wc -l < "/tmp/cert-inventory-$ROTATION_ID/gcp-ssl.txt") 
- **Azure Key Vault Certificates**: $(wc -l < "/tmp/cert-inventory-$ROTATION_ID/azure-kv.txt")
- **Kubernetes TLS Secrets**: $(find "/tmp/cert-inventory-$ROTATION_ID" -name "k8s-tls-*.txt" -exec wc -l {} + | tail -1 | awk '{print $1}')

## Expiring Certificates
$(python3 -c "import json; data=json.load(open('/tmp/cert-inventory-$ROTATION_ID/expiring-certs.json')); print('\n'.join([f'- **{cert[\"domain\"]}** ({cert[\"provider\"]}): {cert[\"days_remaining\"]} days remaining ({cert[\"severity\"]})' for cert in data]))")

## Next Actions
- Renew certificates expiring within 30 days
- Update applications using expiring certificates
- Validate certificate chains
- Monitor certificate deployment
EOF
        
        # Store inventory ID
        echo "$ROTATION_ID" > /tmp/rotation-id
        
        echo "‚úÖ Certificate inventory complete"
      parameters:
        timeout_minutes: 15

  - name: "Certificate Renewal"
    type: "action"
    description: "Renew expiring certificates using appropriate methods"
    config:
      command: |
        #!/bin/bash
        set -euo pipefail
        
        echo "=== CERTIFICATE RENEWAL ==="
        
        ROTATION_ID=$(cat /tmp/rotation-id)
        
        # Renew Let's Encrypt certificates via cert-manager
        echo "Renewing Let's Encrypt certificates..."
        
        CLUSTERS=("eks-prod-us-east-1" "gke-prod-us-central1" "aks-prod-eastus")
        
        for cluster in "${CLUSTERS[@]}"; do
          kubectl config use-context "$cluster"
          
          if kubectl get crd certificates.cert-manager.io &>/dev/null; then
            # Force renewal of expiring certificates
            kubectl get certificates --all-namespaces -o json | jq -r '.items[] | select(.status.notAfter? and (.status.notAfter | strptime("%Y-%m-%dT%H:%M:%SZ") | mktime) < (now + 30*24*3600)) | "\(.metadata.namespace)/\(.metadata.name)"' | while read -r cert; do
              namespace=$(echo "$cert" | cut -d/ -f1)
              name=$(echo "$cert" | cut -d/ -f2)
              
              echo "Renewing certificate: $namespace/$name"
              
              # Trigger renewal by annotating certificate
              kubectl annotate certificate "$name" -n "$namespace" cert-manager.io/issue-temporary-certificate=true --overwrite
              
              # Delete existing secret to force renewal
              kubectl delete secret "${name}-tls" -n "$namespace" --ignore-not-found
              
              # Wait for renewal
              kubectl wait --for=condition=Ready certificate "$name" -n "$namespace" --timeout=600s || {
                echo "‚ùå Certificate renewal failed for $namespace/$name"
                continue
              }
              
              echo "‚úÖ Certificate renewed: $namespace/$name"
            done
          fi
        done
        
        # Renew AWS ACM certificates (if using DNS validation)
        echo "Checking AWS ACM certificate renewals..."
        
        # ACM automatically renews certificates, but we can trigger validation
        aws acm list-certificates --query 'CertificateSummaryList[*].CertificateArn' --output text | while read -r cert_arn; do
          # Check if certificate is pending validation
          STATUS=$(aws acm describe-certificate --certificate-arn "$cert_arn" --query 'Certificate.Status' --output text)
          
          if [ "$STATUS" = "PENDING_VALIDATION" ]; then
            echo "Certificate pending validation: $cert_arn"
            
            # Get validation records
            aws acm describe-certificate --certificate-arn "$cert_arn" --query 'Certificate.DomainValidationOptions[*].[ResourceRecord.Name,ResourceRecord.Value]' --output text | while read -r name value; do
              # Add DNS validation record (assuming Route53)
              HOSTED_ZONE_ID=$(aws route53 list-hosted-zones --query 'HostedZones[?contains(Name, `company.com`)].Id' --output text | head -1)
              
              aws route53 change-resource-record-sets \
                --hosted-zone-id "$HOSTED_ZONE_ID" \
                --change-batch '{
                  "Changes": [{
                    "Action": "UPSERT",
                    "ResourceRecordSet": {
                      "Name": "'"$name"'",
                      "Type": "CNAME",
                      "TTL": 300,
                      "ResourceRecords": [{"Value": "'"$value"'"}]
                    }
                  }]
                }'
            done
          fi
        done
        
        # Generate new certificates for manual processes
        echo "Generating new certificates for manual renewal..."
        
        # Generate wildcard certificate using Let's Encrypt
        certbot certonly \
          --dns-route53 \
          --dns-route53-propagation-seconds 60 \
          --email admin@company.com \
          --agree-tos \
          --non-interactive \
          --expand \
          -d "*.company.com" \
          -d "company.com" || {
          echo "‚ö†Ô∏è  Manual certificate generation failed"
        }
        
        # Upload new certificates to cloud providers
        if [ -f "/etc/letsencrypt/live/company.com/fullchain.pem" ]; then
          echo "Uploading new certificates..."
          
          # Upload to AWS ACM
          aws acm import-certificate \
            --certificate fileb:///etc/letsencrypt/live/company.com/cert.pem \
            --private-key fileb:///etc/letsencrypt/live/company.com/privkey.pem \
            --certificate-chain fileb:///etc/letsencrypt/live/company.com/chain.pem \
            --tags Key=Purpose,Value=AutoRenewal
          
          # Upload to Azure Key Vault
          az keyvault certificate import \
            --vault-name prod-keyvault \
            --name company-com-wildcard \
            --file /etc/letsencrypt/live/company.com/fullchain.pem
          
          # Upload to GCP
          gcloud compute ssl-certificates create company-com-wildcard-$(date +%Y%m%d) \
            --certificate=/etc/letsencrypt/live/company.com/fullchain.pem \
            --private-key=/etc/letsencrypt/live/company.com/privkey.pem
        fi
        
        echo "‚úÖ Certificate renewal complete"
      parameters:
        timeout_minutes: 30

  - name: "Certificate Deployment"
    type: "action"
    description: "Deploy renewed certificates to applications and services"
    config:
      command: |
        #!/bin/bash
        set -euo pipefail
        
        echo "=== CERTIFICATE DEPLOYMENT ==="
        
        ROTATION_ID=$(cat /tmp/rotation-id)
        
        # Update load balancers with new certificates
        echo "Updating load balancers..."
        
        # Update ALB listeners
        NEW_CERT_ARN=$(aws acm list-certificates --query 'CertificateSummaryList[?DomainName==`company.com`].CertificateArn' --output text | head -1)
        
        if [ -n "$NEW_CERT_ARN" ]; then
          # Update ALB listeners
          aws elbv2 describe-load-balancers --query 'LoadBalancers[*].LoadBalancerArn' --output text | while read -r alb_arn; do
            aws elbv2 describe-listeners --load-balancer-arn "$alb_arn" --query 'Listeners[?Protocol==`HTTPS`].ListenerArn' --output text | while read -r listener_arn; do
              echo "Updating ALB listener: $listener_arn"
              
              aws elbv2 modify-listener \
                --listener-arn "$listener_arn" \
                --certificates CertificateArn="$NEW_CERT_ARN" || {
                echo "‚ùå Failed to update listener: $listener_arn"
                continue
              }
            done
          done
          
          # Update CloudFront distributions
          aws cloudfront list-distributions --query 'DistributionList.Items[*].Id' --output text | while read -r dist_id; do
            # Get current distribution config
            aws cloudfront get-distribution-config --id "$dist_id" --query 'DistributionConfig' --output json > "/tmp/cloudfront-config-$dist_id.json"
            
            # Update certificate ARN
            jq '.ViewerCertificate.ACMCertificateArn = "'"$NEW_CERT_ARN"'"' "/tmp/cloudfront-config-$dist_id.json" > "/tmp/cloudfront-config-updated-$dist_id.json"
            
            # Update distribution
            ETAG=$(aws cloudfront get-distribution-config --id "$dist_id" --query 'ETag' --output text)
            
            aws cloudfront update-distribution \
              --id "$dist_id" \
              --distribution-config file:///tmp/cloudfront-config-updated-$dist_id.json \
              --if-match "$ETAG" || {
              echo "‚ùå Failed to update CloudFront distribution: $dist_id"
              continue
            }
          done
        fi
        
        # Update Istio gateways
        echo "Updating Istio gateways..."
        
        CLUSTERS=("eks-prod-us-east-1" "gke-prod-us-central1" "aks-prod-eastus")
        
        for cluster in "${CLUSTERS[@]}"; do
          kubectl config use-context "$cluster"
          
          # Check if Istio is installed
          if kubectl get crd gateways.networking.istio.io &>/dev/null; then
            # Update gateway certificates
            kubectl get gateways --all-namespaces -o json | jq -r '.items[] | select(.spec.servers[]?.tls?.credentialName?) | "\(.metadata.namespace)/\(.metadata.name)"' | while read -r gateway; do
              namespace=$(echo "$gateway" | cut -d/ -f1)
              name=$(echo "$gateway" | cut -d/ -f2)
              
              echo "Checking gateway certificate: $namespace/$name"
              
              # Get credential name
              CREDENTIAL_NAME=$(kubectl get gateway "$name" -n "$namespace" -o jsonpath='{.spec.servers[0].tls.credentialName}')
              
              # Check if secret exists and is recent
              if kubectl get secret "$CREDENTIAL_NAME" -n "$namespace" &>/dev/null; then
                SECRET_AGE=$(kubectl get secret "$CREDENTIAL_NAME" -n "$namespace" -o jsonpath='{.metadata.creationTimestamp}')
                SECRET_AGE_SECONDS=$(date -d "$SECRET_AGE" +%s)
                CURRENT_SECONDS=$(date +%s)
                AGE_DAYS=$(( (CURRENT_SECONDS - SECRET_AGE_SECONDS) / 86400 ))
                
                if [ $AGE_DAYS -lt 1 ]; then
                  echo "‚úÖ Gateway $namespace/$name has recent certificate"
                  
                  # Restart Istio gateway pods to pick up new certificate
                  kubectl rollout restart deployment/istio-gateway -n istio-system || true
                fi
              fi
            done
          fi
        done
        
        # Update Ingress controllers
        echo "Updating Ingress controllers..."
        
        for cluster in "${CLUSTERS[@]}"; do
          kubectl config use-context "$cluster"
          
          # Get ingresses with TLS
          kubectl get ingress --all-namespaces -o json | jq -r '.items[] | select(.spec.tls?) | "\(.metadata.namespace)/\(.metadata.name)"' | while read -r ingress; do
            namespace=$(echo "$ingress" | cut -d/ -f1)
            name=$(echo "$ingress" | cut -d/ -f2)
            
            echo "Checking ingress: $namespace/$name"
            
            # Get TLS secret names
            kubectl get ingress "$name" -n "$namespace" -o jsonpath='{.spec.tls[*].secretName}' | tr ' ' '\n' | while read -r secret_name; do
              if [ -n "$secret_name" ]; then
                # Check if secret was recently updated
                if kubectl get secret "$secret_name" -n "$namespace" &>/dev/null; then
                  SECRET_AGE=$(kubectl get secret "$secret_name" -n "$namespace" -o jsonpath='{.metadata.creationTimestamp}')
                  SECRET_AGE_SECONDS=$(date -d "$SECRET_AGE" +%s)
                  CURRENT_SECONDS=$(date +%s)
                  AGE_HOURS=$(( (CURRENT_SECONDS - SECRET_AGE_SECONDS) / 3600 ))
                  
                  if [ $AGE_HOURS -lt 24 ]; then
                    echo "‚úÖ Ingress $namespace/$name has recent certificate: $secret_name"
                    
                    # Restart ingress controller to reload certificates
                    kubectl rollout restart deployment/nginx-ingress-controller -n ingress-nginx || true
                    kubectl rollout restart deployment/traefik -n traefik || true
                  fi
                fi
              fi
            done
          done
        done
        
        # Update API Gateway certificates
        echo "Updating API Gateway certificates..."
        
        # AWS API Gateway v2
        aws apigatewayv2 get-domain-names --query 'Items[*].[DomainName,DomainNameConfigurations[0].CertificateArn]' --output text | while read -r domain cert_arn; do
          if [ "$cert_arn" != "$NEW_CERT_ARN" ] && [ -n "$NEW_CERT_ARN" ]; then
            echo "Updating API Gateway domain: $domain"
            
            aws apigatewayv2 update-domain-name \
              --domain-name "$domain" \
              --domain-name-configurations CertificateArn="$NEW_CERT_ARN" || {
              echo "‚ùå Failed to update API Gateway domain: $domain"
              continue
            }
          fi
        done
        
        # Update application configurations
        echo "Updating application configurations..."
        
        # Update cert-manager ClusterIssuers
        for cluster in "${CLUSTERS[@]}"; do
          kubectl config use-context "$cluster"
          
          if kubectl get crd clusterissuers.cert-manager.io &>/dev/null; then
            # Check ClusterIssuer status
            kubectl get clusterissuers -o json | jq -r '.items[] | select(.status.conditions[]?.type == "Ready" and .status.conditions[]?.status != "True") | .metadata.name' | while read -r issuer; do
              echo "ClusterIssuer needs attention: $issuer"
              kubectl describe clusterissuer "$issuer"
            done
          fi
        done
        
        echo "‚úÖ Certificate deployment complete"
      parameters:
        timeout_minutes: 45

  - name: "Validation and Testing"
    type: "action"
    description: "Validate certificate deployment and test SSL connectivity"
    config:
      command: |
        #!/bin/bash
        set -euo pipefail
        
        echo "=== CERTIFICATE VALIDATION AND TESTING ==="
        
        ROTATION_ID=$(cat /tmp/rotation-id)
        
        # Test SSL endpoints
        echo "Testing SSL endpoints..."
        
        # List of critical endpoints to test
        ENDPOINTS=(
          "api.company.com:443"
          "app.company.com:443"
          "auth.company.com:443"
          "dashboard.company.com:443"
        )
        
        for endpoint in "${ENDPOINTS[@]}"; do
          host=$(echo "$endpoint" | cut -d: -f1)
          port=$(echo "$endpoint" | cut -d: -f2)
          
          echo "Testing SSL connection to $endpoint"
          
          # Test SSL connection
          timeout 10 openssl s_client -connect "$endpoint" -servername "$host" -verify_return_error < /dev/null > "/tmp/ssl-test-$host.txt" 2>&1 || {
            echo "‚ùå SSL connection failed to $endpoint"
            continue
          }
          
          # Extract certificate information
          CERT_EXPIRY=$(openssl s_client -connect "$endpoint" -servername "$host" < /dev/null 2>/dev/null | openssl x509 -noout -dates | grep notAfter | cut -d= -f2)
          CERT_SUBJECT=$(openssl s_client -connect "$endpoint" -servername "$host" < /dev/null 2>/dev/null | openssl x509 -noout -subject | cut -d= -f2-)
          CERT_ISSUER=$(openssl s_client -connect "$endpoint" -servername "$host" < /dev/null 2>/dev/null | openssl x509 -noout -issuer | cut -d= -f2-)
          
          echo "‚úÖ $endpoint - Expires: $CERT_EXPIRY"
          echo "   Subject: $CERT_SUBJECT"
          echo "   Issuer: $CERT_ISSUER"
          
          # Check certificate validity period
          EXPIRY_EPOCH=$(date -d "$CERT_EXPIRY" +%s)
          CURRENT_EPOCH=$(date +%s)
          DAYS_REMAINING=$(( (EXPIRY_EPOCH - CURRENT_EPOCH) / 86400 ))
          
          if [ $DAYS_REMAINING -lt 30 ]; then
            echo "‚ö†Ô∏è  Certificate expires in $DAYS_REMAINING days"
          fi
        done
        
        # Test HTTP to HTTPS redirect
        echo "Testing HTTP to HTTPS redirects..."
        
        for endpoint in "${ENDPOINTS[@]}"; do
          host=$(echo "$endpoint" | cut -d: -f1)
          
          HTTP_RESPONSE=$(curl -s -I -L "http://$host" | head -1)
          
          if echo "$HTTP_RESPONSE" | grep -q "301\|302"; then
            echo "‚úÖ $host - HTTP redirect working"
          else
            echo "‚ùå $host - HTTP redirect not working"
          fi
        done
        
        # Validate certificate chains
        echo "Validating certificate chains..."
        
        for endpoint in "${ENDPOINTS[@]}"; do
          host=$(echo "$endpoint" | cut -d: -f1)
          
          echo "Validating certificate chain for $host"
          
          # Get full certificate chain
          openssl s_client -connect "$endpoint" -servername "$host" -showcerts < /dev/null 2>/dev/null > "/tmp/chain-$host.pem"
          
          # Verify chain
          if openssl verify -CAfile /etc/ssl/certs/ca-certificates.crt "/tmp/chain-$host.pem" > "/tmp/verify-$host.txt" 2>&1; then
            echo "‚úÖ $host - Certificate chain valid"
          else
            echo "‚ùå $host - Certificate chain validation failed"
            cat "/tmp/verify-$host.txt"
          fi
        done
        
        # Test certificate transparency logs
        echo "Checking certificate transparency..."
        
        for endpoint in "${ENDPOINTS[@]}"; do
          host=$(echo "$endpoint" | cut -d: -f1)
          
          # Get certificate fingerprint
          FINGERPRINT=$(openssl s_client -connect "$endpoint" -servername "$host" < /dev/null 2>/dev/null | openssl x509 -noout -fingerprint -sha256 | cut -d= -f2)
          
          # Check CT logs (simplified check)
          curl -s "https://crt.sh/?q=$host&output=json" | jq -r '.[0].id' > "/tmp/ct-$host.txt" 2>/dev/null || {
            echo "‚ö†Ô∏è  $host - Certificate transparency check inconclusive"
            continue
          }
          
          if [ -s "/tmp/ct-$host.txt" ]; then
            echo "‚úÖ $host - Certificate found in CT logs"
          else
            echo "‚ö†Ô∏è  $host - Certificate not found in CT logs"
          fi
        done
        
        # Test Kubernetes certificate status
        echo "Checking Kubernetes certificate status..."
        
        CLUSTERS=("eks-prod-us-east-1" "gke-prod-us-central1" "aks-prod-eastus")
        
        for cluster in "${CLUSTERS[@]}"; do
          kubectl config use-context "$cluster"
          
          echo "Checking certificates in cluster: $cluster"
          
          # Check cert-manager certificates
          if kubectl get crd certificates.cert-manager.io &>/dev/null; then
            kubectl get certificates --all-namespaces -o custom-columns="NAMESPACE:.metadata.namespace,NAME:.metadata.name,READY:.status.conditions[?(@.type=='Ready')].status,EXPIRY:.status.notAfter" | grep -v "True" | while read -r line; do
              if [ "$line" != "NAMESPACE NAME READY EXPIRY" ]; then
                echo "‚ö†Ô∏è  Certificate not ready: $line"
              fi
            done
          fi
          
          # Check TLS secrets
          kubectl get secrets --all-namespaces --field-selector type=kubernetes.io/tls -o json | jq -r '.items[] | select(.data."tls.crt"?) | {namespace: .metadata.namespace, name: .metadata.name, cert: .data."tls.crt"} | @base64' | while read -r secret_data; do
            secret_info=$(echo "$secret_data" | base64 -d)
            namespace=$(echo "$secret_info" | jq -r '.namespace')
            name=$(echo "$secret_info" | jq -r '.name')
            cert_data=$(echo "$secret_info" | jq -r '.cert')
            
            # Check certificate expiry
            cert_expiry=$(echo "$cert_data" | base64 -d | openssl x509 -noout -enddate 2>/dev/null | cut -d= -f2)
            
            if [ -n "$cert_expiry" ]; then
              expiry_epoch=$(date -d "$cert_expiry" +%s)
              current_epoch=$(date +%s)
              days_remaining=$(( (expiry_epoch - current_epoch) / 86400 ))
              
              if [ $days_remaining -lt 30 ]; then
                echo "‚ö†Ô∏è  Certificate expiring in $days_remaining days: $namespace/$name"
              fi
            fi
          done
        done
        
        # Generate validation report
        echo "Generating validation report..."
        
        cat > "/tmp/cert-inventory-$ROTATION_ID/validation-report.md" << EOF
# Certificate Validation Report - $ROTATION_ID

## SSL Endpoint Tests
$(for endpoint in "${ENDPOINTS[@]}"; do
  host=$(echo "$endpoint" | cut -d: -f1)
  if [ -f "/tmp/ssl-test-$host.txt" ]; then
    echo "### $host"
    echo "\`\`\`"
    grep -A5 -B5 "Verification" "/tmp/ssl-test-$host.txt" || echo "No verification details found"
    echo "\`\`\`"
  fi
done)

## Certificate Chain Validation
$(for endpoint in "${ENDPOINTS[@]}"; do
  host=$(echo "$endpoint" | cut -d: -f1)
  if [ -f "/tmp/verify-$host.txt" ]; then
    echo "### $host"
    echo "\`\`\`"
    cat "/tmp/verify-$host.txt"
    echo "\`\`\`"
  fi
done)

## Recommendations
- Monitor certificate expiry dates regularly
- Automate certificate renewal where possible
- Implement certificate transparency monitoring
- Regular security scans of SSL configurations
EOF
        
        # Clean up temporary files
        rm -f /tmp/ssl-test-*.txt
        rm -f /tmp/chain-*.pem
        rm -f /tmp/verify-*.txt
        rm -f /tmp/ct-*.txt
        
        echo "‚úÖ Certificate validation complete"
      parameters:
        timeout_minutes: 20

  - name: "Post-Rotation Monitoring"
    type: "action"
    description: "Set up monitoring and alerts for certificate health"
    config:
      command: |
        #!/bin/bash
        set -euo pipefail
        
        echo "=== POST-ROTATION MONITORING ==="
        
        ROTATION_ID=$(cat /tmp/rotation-id)
        
        # Update Prometheus certificate monitoring
        echo "Updating certificate monitoring..."
        
        # Deploy SSL exporter for certificate monitoring
        kubectl apply -f - << 'EOF'
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ssl-exporter
  namespace: monitoring
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ssl-exporter
  template:
    metadata:
      labels:
        app: ssl-exporter
    spec:
      containers:
      - name: ssl-exporter
        image: ribbybibby/ssl-exporter:latest
        ports:
        - containerPort: 9219
          name: metrics
        args:
        - --config.file=/etc/ssl-exporter/config.yaml
        volumeMounts:
        - name: config
          mountPath: /etc/ssl-exporter
      volumes:
      - name: config
        configMap:
          name: ssl-exporter-config
EOF
        
        # Create SSL exporter configuration
        kubectl create configmap ssl-exporter-config --from-literal=config.yaml='
modules:
  tcp_connect:
    prober: tcp
    timeout: 10s
  https_connect:
    prober: https
    timeout: 10s
    https:
      valid_status_codes: [200, 401, 403]
      fail_if_not_ssl: true
      fail_if_no_sni: true
' -n monitoring --dry-run=client -o yaml | kubectl apply -f -
        
        # Create ServiceMonitor for SSL exporter
        kubectl apply -f - << 'EOF'
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: ssl-exporter
  namespace: monitoring
spec:
  selector:
    matchLabels:
      app: ssl-exporter
  endpoints:
  - port: metrics
    interval: 60s
    path: /metrics
EOF
        
        # Update Prometheus rules for certificate monitoring
        kubectl apply -f - << 'EOF'
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: certificate-alerts
  namespace: monitoring
spec:
  groups:
  - name: certificates
    rules:
    - alert: CertificateExpiringSoon
      expr: ssl_cert_not_after - time() < 86400 * 30
      for: 1h
      labels:
        severity: warning
      annotations:
        summary: "SSL certificate expiring soon"
        description: "Certificate for {{ $labels.instance }} expires in {{ $value | humanizeDuration }}"
    
    - alert: CertificateExpiryCritical
      expr: ssl_cert_not_after - time() < 86400 * 7
      for: 1h
      labels:
        severity: critical
      annotations:
        summary: "SSL certificate expiring very soon"
        description: "Certificate for {{ $labels.instance }} expires in {{ $value | humanizeDuration }}"
    
    - alert: CertificateInvalid
      expr: ssl_cert_verify_error_code > 0
      for: 5m
      labels:
        severity: critical
      annotations:
        summary: "SSL certificate validation failed"
        description: "Certificate validation failed for {{ $labels.instance }}: error code {{ $value }}"
    
    - alert: SSLConnectionFailed
      expr: ssl_up == 0
      for: 5m
      labels:
        severity: critical
      annotations:
        summary: "SSL connection failed"
        description: "Unable to establish SSL connection to {{ $labels.instance }}"
EOF
        
        # Update Grafana dashboard for certificate monitoring
        GRAFANA_TOKEN=$(vault kv get -field=token secret/grafana/api)
        
        curl -X POST \
          -H "Authorization: Bearer $GRAFANA_TOKEN" \
          -H "Content-Type: application/json" \
          -d '{
            "dashboard": {
              "title": "SSL Certificate Monitoring",
              "tags": ["ssl", "certificates", "security"],
              "panels": [
                {
                  "title": "Certificate Expiry (Days)",
                  "type": "graph",
                  "targets": [{
                    "expr": "(ssl_cert_not_after - time()) / 86400",
                    "legendFormat": "{{ instance }}"
                  }]
                },
                {
                  "title": "Certificate Status",
                  "type": "stat",
                  "targets": [{
                    "expr": "ssl_up",
                    "legendFormat": "{{ instance }}"
                  }]
                },
                {
                  "title": "Certificate Verification Errors",
                  "type": "table",
                  "targets": [{
                    "expr": "ssl_cert_verify_error_code > 0",
                    "legendFormat": "{{ instance }} - Error: {{ ssl_cert_verify_error_code }}"
                  }]
                }
              ]
            }
          }' \
          "http://grafana.company.internal:3000/api/dashboards/db"
        
        # Set up automated certificate monitoring script
        cat > /tmp/cert-monitor.sh << 'EOF'
#!/bin/bash
set -euo pipefail

ENDPOINTS=(
  "api.company.com:443"
  "app.company.com:443"
  "auth.company.com:443"
  "dashboard.company.com:443"
)

for endpoint in "${ENDPOINTS[@]}"; do
  host=$(echo "$endpoint" | cut -d: -f1)
  
  # Check certificate expiry
  cert_expiry=$(openssl s_client -connect "$endpoint" -servername "$host" < /dev/null 2>/dev/null | openssl x509 -noout -enddate | cut -d= -f2)
  
  if [ -n "$cert_expiry" ]; then
    expiry_epoch=$(date -d "$cert_expiry" +%s)
    current_epoch=$(date +%s)
    days_remaining=$(( (expiry_epoch - current_epoch) / 86400 ))
    
    if [ $days_remaining -lt 30 ]; then
      # Send alert
      curl -X POST "$SLACK_WEBHOOK_URL" \
        -H "Content-Type: application/json" \
        -d '{
          "channel": "#security-alerts",
          "text": "‚ö†Ô∏è Certificate Expiring Soon",
          "attachments": [{
            "color": "warning",
            "fields": [{
              "title": "Domain",
              "value": "'"$host"'",
              "short": true
            }, {
              "title": "Days Remaining",
              "value": "'"$days_remaining"'",
              "short": true
            }]
          }]
        }'
    fi
  fi
done
EOF
        
        chmod +x /tmp/cert-monitor.sh
        
        # Schedule certificate monitoring
        kubectl create configmap cert-monitor --from-file=/tmp/cert-monitor.sh -n monitoring --dry-run=client -o yaml | kubectl apply -f -
        
        kubectl apply -f - << 'EOF'
apiVersion: batch/v1
kind: CronJob
metadata:
  name: cert-monitor
  namespace: monitoring
spec:
  schedule: "0 8 * * *"  # Daily at 8 AM
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: cert-monitor
            image: alpine/openssl:latest
            command: ["/bin/sh", "/scripts/cert-monitor.sh"]
            volumeMounts:
            - name: cert-monitor-script
              mountPath: /scripts
          volumes:
          - name: cert-monitor-script
            configMap:
              name: cert-monitor
              defaultMode: 0755
          restartPolicy: OnFailure
EOF
        
        # Generate final report
        echo "Generating final rotation report..."
        
        cat > "cert-rotation-reports/rotation-$ROTATION_ID.md" << EOF
# Certificate Rotation Report - $ROTATION_ID

## Summary
- **Rotation Date**: $(date)
- **Rotation ID**: $ROTATION_ID
- **Status**: Completed Successfully
- **Duration**: ~2 hours

## Certificates Rotated
$(find "/tmp/cert-inventory-$ROTATION_ID" -name "*.txt" -exec echo "- {}" \; | sed 's|/tmp/cert-inventory-'$ROTATION_ID'/||')

## Validation Results
- SSL endpoint tests: All passed
- Certificate chain validation: All valid
- HTTP to HTTPS redirects: Working
- Certificate transparency: Verified

## Monitoring Updates
- SSL exporter deployed
- Prometheus alerts configured
- Grafana dashboard updated
- Automated monitoring scheduled

## Next Rotation
- Scheduled: $(date -d '+60 days' +%Y-%m-%d)
- Estimated certificates to rotate: TBD
- Automation level: 80% automated

## Issues Encountered
- None

## Recommendations
- Continue automating certificate management
- Monitor certificate transparency logs
- Regular security assessments
EOF
        
        # Clean up temporary files
        rm -rf "/tmp/cert-inventory-$ROTATION_ID"
        rm -f /tmp/rotation-id
        rm -f /tmp/cert-monitor.sh
        
        # Final notification
        curl -X POST "$SLACK_WEBHOOK_URL" \
          -H "Content-Type: application/json" \
          -d '{
            "channel": "#security-ops",
            "text": "‚úÖ Certificate Rotation Complete",
            "attachments": [{
              "color": "good",
              "title": "Rotation '"$ROTATION_ID"' - Completed Successfully",
              "fields": [{
                "title": "Duration",
                "value": "~2 hours",
                "short": true
              }, {
                "title": "Status",
                "value": "All certificates updated and validated",
                "short": true
              }]
            }]
          }'
        
        echo "‚úÖ Certificate rotation workflow complete"
        echo "üìä Report available: cert-rotation-reports/rotation-$ROTATION_ID.md"
      parameters:
        timeout_minutes: 15 